---
title: "An introduction to TKCat"
subtitle: "Using Tailored Knowledge Catalogs for improving data accessibility"
author: '[Patrice Godard](mailto:patrice.godard@gmail.com?Subject=TKCat)'
date: "`r format(Sys.time(), '%B %d %Y')`"
bibliography: references.bib
link-citations: yes
output: 
   html_document:
      fig_height: 6
      fig_width: 8
      keep_md: no
      number_sections: yes
      self_contained: true
      theme: cerulean
      toc: yes
      toc_float: yes
      code_folding: show
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 80
---

<style>
   @font-face {
      font-family: 'firaCode';
      src: url('https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/ttf/FiraCode-Regular.ttf');
      font-style: normal;
      font-weight: normal;
   }
   @font-face {
      font-family: 'firaCode';
      src: url('https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/ttf/FiraCode-Bold.ttf');
      font-weight: bold;
      font-style: normal;
   } 
   @font-face {
   	font-family: 'firaCode';
   	src: url('https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/ttf/FiraCode-Retina.ttf');
   	font-weight: retina;
   	font-style: italic;
   }
   code,pre {
       font-family: firaCode !important;
       font-variant-ligatures: contextual;
   }
   x-screen x-row { font-variant-ligatures: contextual; }
</style>

```{r setup, include=TRUE, warning=FALSE, message=FALSE, echo=FALSE}
library(knitr)
library(kableExtra)
opts_chunk$set(
   include=TRUE,
   warning=TRUE, echo=TRUE, message=TRUE,
   concordance=TRUE
)
library(TKCat)
library(readr)
```

```{r child = 'supp/urls.Rmd'}
```

# Aim

In this document, we want to show how the [ReDaMoR][redamor] and [TKCat][tkcat]
R packages can be used to:

- document a dataset with a data model;
- get a modeled database (MDB)
by binding the data model to the dataset after their confrontation/validation;
- document concept collections that can be used to integrate different MDBs;
- load MDBs into a Clickhouse database to make them easily FAIR
(Findable, Accessible, Interoperable, Reusable).

# Requirements

The following libraries must be installed:

```{r}
## The following packages are required by TKCat
library(magrittr)
library(dplyr)
library(readr)
library(RClickhouse) # >= 0.6.0
library(ReDaMoR)     # >= 0.5.2
library(TKCat)       # >= 0.7.0
## The following packages are used in this vignette but not required by TKCat
library(data.tree)
```


# A minimal example

This example focuses on the [Human Phenotype Ontology (HPO)](#hpo).
The HPO aims to provide a standardized vocabulary of
phenotypic abnormalities encountered in human diseases [@kohler_expansion_2019].

## Loading the data

A subset of the HPO is provided within the [ReDaMoR][redamor] package.
We can read some of the tables as follow:

```{r, message=FALSE}
library(readr)
hpo_data_dir <- system.file("examples/HPO-subset", package="ReDaMoR")
```

The `HPO_hp` table gathers human phenotype identifiers, names and descriptions:

```{r, message=FALSE}
HPO_hp <- readr::read_tsv(
   file.path(hpo_data_dir, "HPO_hp.txt")
)
HPO_hp
```

The `HPO_diseases` table gathers disease identifiers and labels from different
disease database.

```{r, message=FALSE}
HPO_diseases <- readr::read_tsv(
   file.path(hpo_data_dir, "HPO_diseases.txt")
)
HPO_diseases
```

The `HPO_diseaseHP` table indicates which phenotype is triggered by
each disease.

```{r, message=FALSE}
HPO_diseaseHP <- readr::read_tsv(
   file.path(hpo_data_dir, "HPO_diseaseHP.txt")
)
HPO_diseaseHP
```

## Creating a data model with ReDaMoR

The [ReDaMoR][redamor] package can be used for drafting a data model from a
set of table: 

```{r, out.height="200px"}
mhpo_dm <- ReDaMoR::df_to_model(HPO_hp, HPO_diseases, HPO_diseaseHP)
mhpo_dm %>%
   ReDaMoR::auto_layout(lengthMultiplier=80) %>% 
   plot()
```

This data model is minimal: only the name of the tables, their fields and their
types are documented. There is no additional constrain regarding the uniqueness
or the completeness of the fields. Also there is no information regarding the
relationships between the different tables.
The `model_relational_data()` can be used to improve the documentation of the
dataset according to what we know about it. This function raises a graphical
interface for manipulating and modifying the data model
(see [ReDaMoR documentation](https://patzaw.github.io/ReDaMoR/ReDaMoR.html)).

```{r, eval=FALSE}
mhpo_dm <- ReDaMoR::model_relational_data(mhpo_dm)
```

```{r, echo=FALSE}
mhpo_dm <- ReDaMoR::read_json_data_model(
   system.file("examples/HPO-model.json", package="ReDaMoR")
)[c("HPO_hp", "HPO_diseases", "HPO_diseaseHP")]
```

Below is the model we get after completing it using the function above.

```{r, out.height="200px"}
plot(mhpo_dm)
```

In this model, we can see that:

- *id* is the **primary key** of the *HPO_hp* table, and therefore
this field must be **unique**;
- *db*/*id* form the  **primary key** of the *HPO_diseases* table and must
also be **unique** when taken together;
- all the fields excepted *description* (in the *HPO_hp* table) are complete
(they cannot be NA);
- the *HPO_diseaseHP* table refers to the *HPO_hp* table using its *HPO_hp*
fields and to the *HPO_diseases* table using its *db* and *id* fields
(such details are shown when putting cursor over the edges).

Moreover, some comments are added at the table and at the field level to give
a better understanding of the data
(shown when putting the cursor over the tables).

## Binding the model to the data in an MDB object

The data model can be explicitly bound to the data in
an MDB (Modeled DataBase) object as shown below.
However, when trying to build the object with the tables we've read and the
data model we have edited, we get the following error message.

```{r, echo=FALSE, results='hide'}
try(
   mhpo_db <- memoMDB(
      dataTables=list(
         HPO_hp=HPO_hp, HPO_diseases=HPO_diseases, HPO_diseaseHP=HPO_diseaseHP
      ),
      dataModel=mhpo_dm,
      dbInfo=list(name="miniHPO")
   ),
   silent=TRUE
)
```

```{r, eval=FALSE}
mhpo_db <- memoMDB(
   dataTables=list(
      HPO_hp=HPO_hp, HPO_diseases=HPO_diseases, HPO_diseaseHP=HPO_diseaseHP
   ),
   dataModel=mhpo_dm,
   dbInfo=list(name="miniHPO")
)
```

<div style="background-color:#FFFACD; border-top:5px solid black; border-bottom:5px solid black; margin-top:50px; margin-bottom:50px">

```{r, echo=FALSE, results='asis'}
get_confrontation_report() %>% 
   format_confrontation_report_md(
      title="miniHPO",
      level=2, numbered=FALSE
   ) %>% 
   cat()
```

</div>

Indeed, according to the edited model (not the very first one automatically
created by ReDaMoR), the `HPO_hp$level` field should contain *integer* values
and the `HPO_diseases$id` and `HPO_diseaseHP$id` fields should
contain *character* values.
The type of the data is among the data model features that are automatically
checked when building an MDB object (along with uniqueness or NA values
for example).

To avoid this error, we can either change the type of the columns of the
data tables:

```{r}
HPO_hp <- mutate(HPO_hp, level=as.integer(level))
HPO_diseases <- mutate(HPO_diseases, id=as.character(id))
HPO_diseaseHP <- mutate(HPO_diseaseHP, id=as.character(id))
mhpo_db <- memoMDB(
   dataTables=list(
      HPO_hp=HPO_hp, HPO_diseases=HPO_diseases, HPO_diseaseHP=HPO_diseaseHP
   ),
   dataModel=mhpo_dm,
   dbInfo=list(name="miniHPO")
)
```

Or we can use the data model to read the data in a fileMDB object:

```{r}
f_mhpo_db <- read_fileMDB(
   path=hpo_data_dir,
   dbInfo=list(name="miniHPO"),
   dataModel=mhpo_dm
)
```

The `read_fileMDB()` function identifies the text files to read in `path` 
according to the `dataModel`. It uses the types documented in the data model
to read the files. By default, the field delimiter is `\t`, but another can
be defined by writing a `delim` slot in the `dbInfo` parameter
(e.g. `dbInfo=list(name="miniHPO", delim="\t")`).

As shown in the message above, by default, `read_fileMDB()` does not perform
optional checks (*unique* fields, *not nullable* fields, *foreign keys*) and
it only checks data on the 10 first records.
Also, the fileMDB data are not loaded in memory until requested by the user.
The object is then small than the memoMDB object even if they gather the same
information.

```{r}
print(object.size(mhpo_db), units="Kb")
print(object.size(f_mhpo_db), units="Kb")
compare_MDB(former=mhpo_db, new=f_mhpo_db) %>% 
   DT::datatable(
      rownames=FALSE,
      width="75%",
      options=list(dom="t", pageLength=nrow(.))
   )
```

## Adding information about an MDB

In the table above we can see that several pieces of information are expected
in an MDB object even if not mandatory. They can be provided in the `dbInfo`
parameter or added afterward:

- *title*, *description* and *url* are used to give more details about the scope
of the data and their origin.

```{r}
db_info(f_mhpo_db)$title <- "Very small extract of the human phenotype ontology"
db_info(f_mhpo_db)$description <- "For demonstrating ReDaMoR and TKCat capabilities, a very few information from the HPO (human phenotype ontology) has been extracted"
db_info(f_mhpo_db)$url <- "https://hpo.jax.org/app/"
```

- *version* and *maintainer* are related to db information and the data model
whereas *timestamp* should be used to document the data themselves. 

```{r}
db_info(f_mhpo_db)$version <- "0.1"
db_info(f_mhpo_db)$maintainer <- "Patrice Godard"
db_info(f_mhpo_db)$timestamp <- Sys.time()
```

All this information is displayed when printing the object:

```{r}
f_mhpo_db
```

The *"No collection member"* statement will be addressed later in this document.

## Writing an MDB

Once an MDB has been created and documented in can be written in a directory:

```{r, results='hide'}
tmpDir <- tempdir()
as_fileMDB(f_mhpo_db, path=tmpDir, htmlModel=FALSE)
```

The structure of the created directory is the following:

```{r, echo=FALSE}
list.files(
   path=file.path(tmpDir, "miniHPO"),
   recursive=TRUE
) %>% 
   file.path("miniHPO", .) %>%
   data.frame(pathString=.) %>% 
   data.tree::as.Node() %>%
   data.tree::ToDataFrameTree() %>%
   pull(1) %>% 
   cat(sep="\n")
```

All the data are in the *data* folder whereas the data model is written
in a json file in the *model* folder. The *DESCRIPTION.json* file gather
db information and information about how to read the data files
(i.e. `delim`, `na`).

This folder can be shared and it's then easy to get all the data and the
corresponding documentation from it:

```{r}
read_fileMDB(file.path(tmpDir, "miniHPO"))
```

# Building a catalog of MDB with TKCat

## MDB examples

### HPO

As explained above,
a subset of the [HPO][hpo] is provided within the [ReDaMoR][redamor] package.
An MDB object based on files
can be read as shown below. As explained above, the data provided by the `path`
parameter are documented with a model (`dataModel` parameter; also provided
within the ReDaMoR package)
and general information (`dbInfo` parameter).

```{r, results='hide'}
file_hpo <- read_fileMDB(
   path=system.file("examples/HPO-subset", package="ReDaMoR"),
   dataModel=system.file("examples/HPO-model.json", package="ReDaMoR"),
   dbInfo=list(
      "name"="HPO",
      "title"="Data extracted from the HPO database",
      "description"=paste(
         "This is a very small subset of the HPO!",
         "Visit the reference URL for more information."
      ),
      "url"="http://human-phenotype-ontology.github.io/"
   )
)
```

This fileMDB is more complete than the minimal example discussed above, as
shown by the data model drawn below.

```{r}
file_hpo
data_model(file_hpo) %>%
   plot()
```


### ClinVar

A subset of the [ClinVar][clinvar] database is provided
within the [TKCat][tkcat] package.
ClinVar is a freely accessible, public archive of reports of the relationships
among human variations and phenotypes,
with supporting evidence [@landrum_clinvar_2018].
All MDB information is provided in the TKCat package and can be easily read:

```{r, results='hide'}
file_clinvar <- read_fileMDB(
   path=system.file("examples/ClinVar", package="TKCat")
)
```

The data model of this MDB and DB information are shown below:

```{r}
file_clinvar
plot(data_model(file_clinvar))
```

## Creating and exploring an MDB catalog

MDBs can organized in catalog like the following.

```{r}
my_cat <- TKCat(file_hpo, file_clinvar)
```

These catalogs can then be browsed and searched interactively:

```{r, eval=FALSE}
explore_MDBs(my_cat)
```

And they can be also accessed programmatically:

```{r}
list_MDBs(my_cat)
file_clinvar <- get_MDB(my_cat, "ClinVar")
dims(file_clinvar)
file_clinvar$ClinVar_variants
```

## Concept collections

In the ClinVar resource described above 3 collections have been documented.
They are fully described in the table below.

```{r}
collection_members(file_clinvar) %>% 
   DT::datatable(
      rownames=FALSE,
      width="100%",
      options=list(dom="t", pageLength=nrow(.))
   )
```

The first collection is a **BE** collection provided by
the *ClinVar_entrezNames* table
(indicated in the "table" column of the table above).
It means that this table provides identifiers of
biological entities (BE). Four pieces of information are recorded to
unambiguously interpret these identifiers:

- **be** field: the kind of biological entity (in this case "Gene").
- **source** field: the database to which
the identifiers refer (in this case "EntrezGene").
- **organism** field: the organism to which the identifiers refer
(in this case "Homo sapiens" as an organism "Scientific name").
- **identifier** field: the BE identifier itself. In this case (often the case),
the identifier is provided by a table column (`static==FALSE`): "entrez".

The two other collections regard **Condition** and are provided by
the *ClinVar_traits* and the *ClinVar_traitCref* tables.
Three pieces of information are recorded to unambiguously interpret condition
identifiers:

- **condition**: the type of condition (e.g. "Disease" or "HP").
- **source**:  the the database to which the identifiers refer.
- **identifier**: the condition identifier itself.

For the moment, two types of collection are pre-built in the [TKCat][tkcat]
package. But other can be defined by the users (see the dedicated vignette).
The collections locally available can be listed as following:

```{r}
list_local_collections()
```

A collection member can be documented in an MDB as following:

```{r}
file_hpo <- add_collection_member(
   file_hpo, collection="Condition", table="HPO_hp",
   condition=list(value="Phenotype", static=TRUE),
   source=list(value="HP", static=TRUE),
   identifier=list(value="id", static=FALSE)
)
file_hpo <- add_collection_member(
   file_hpo, collection="Condition", table="HPO_diseases",
   condition=list(value="Disease", static=TRUE),
   source=list(value="db", static=FALSE),
   identifier=list(value="id", static=FALSE)
)
collection_members(file_hpo)
```


# TKCat and ClickHouse

An MDB catalog can also be implemented in a [Clickhouse][clickhouse] database
(thanks to the [RClickhouse][rclickhouse] package).
The creation and the management of such a database is described 
[here](https://patzaw.github.io/TKCat/chTKCat-Operations-manual.html).

After connection, `chTKCat` can be used like other `TKCat` objects described
above.

```{r, eval=FALSE}
k <- chTKCat(host="localhost", user="pgodard")
list_MDBs(k)
explore_MDBs(k)
```

Any `MDB` object can then be imported in a TKCat ClickHouse instance
as following:

```{r, eval=FALSE}
create_chMDB(k, "HPO", public=TRUE)
ch_hpo <- as_chMDB(file_hpo, k)
```

It is then accessible to anyone with relevant permissions on the Clickhouse
database.


# References

<!-- Bibliography -->




