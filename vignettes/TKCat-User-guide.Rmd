---
title: "TKCat User guide"
author: "Patrice Godard"
date:  "`r format(Sys.time(), '%B %d, %Y')`"
output:
   rmarkdown::html_vignette:
     number_sections: yes
     self_contained: yes
     toc: yes
     fig_width: 7
     fig_height: 5
vignette: >
   %\VignetteIndexEntry{TKCat User guide}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{css, echo=FALSE}
code{
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r setup, message=FALSE, echo=FALSE, include=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(
   include=TRUE,
   echo=TRUE,
   message=TRUE,
   warning=TRUE,
   cache=FALSE,
   cache.lazy=FALSE
)
complete <- FALSE
library(TKCat)
```

```{r child = 'supp/urls.Rmd'}
```


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Introduction

```{r child = 'supp/genIntro.Rmd'}
```

This vignette focuses on a local usage of TKCat in R console.
Two other vignettes describe more specifically how TKCat can be used with
a [ClickHouse][clickhouse] database from
a [user][chuguide] or an [operational][opman] perspectives.


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Modeled databases and embeded information

A modeled database (MDB) in TKCat gathers the following information:

- General database information including a mandatory *name* and optionally
the following fields: *title*, *description*, *url*, *version* and *maintainer*.
- A data model created using the [ReDaMoR][redamor] package.
- A list of tables corresponding to reference concepts shared by different
MDBs. The way these concepts are identified is defined in specific documents
called collections.
- The data themselves organized according to the data model.

<!------------->
## Reading examples

### HPO

A subset of the [Human Phenotype Ontology (HPO)][hpo]
is provided within the [ReDaMoR][redamor] package.
The HPO aims to provide a standardized vocabulary of phenotypic
abnormalities encountered in human diseases.[!REF!].
A MDB object based on files (see [MDB implementations](#MDB-implementations))
can be read as shown below.
As explained above, the data provided by the `path` parameter are
documented with a model (`dataModel` parameter) and general
information (`dbInfo` parameter).

```{r}
file_hpo <- read_fileMDB(
   path=system.file("examples/HPO-subset", package="ReDaMoR"),
   dataModel=system.file("examples/HPO-model.json", package="ReDaMoR"),
   dbInfo=list(
      "name"="HPO",
      "title"="Data extracted from the HPO database",
      "description"=paste(
         "This is a very small subset of the HPO!",
         "Visit the reference URL for more information."
      ),
      "url"="http://human-phenotype-ontology.github.io/"
   )
)
```

The message displayed in the console indicates if the data fit the data model.
It relies on the `ReDaMoR::confront_data()` functions and check by default
the first 10 rows of each file.

The data model can then be drawn.

```{r}
plot(data_model(file_hpo))
```

In this model, the *HPO_hp* table refers to the concept of phenotype
and the *HPO_disease* to the concept of disease.
These concepts are used to define the condition of individuals.
The **Condition** collection is built in the TKCat package.
Identifying the collection members in an MDB is done by providing
a table of the shape as displayed below and using
the `collection_members()` function.
As described in
the [Merging with collections](#Merging-with-collections) section,
collections identify
concepts shared by different MDB and can be used to merge resources
according to these concepts.

```{r}
cn <- c(
   "collection", "cid",                "resource", "mid", "table",        "field",     "static", "value",    "type"
)
cm <- matrix(data=c(
   "Condition",  "HPO_conditions_1.0", "HPO",      1,     "HPO_hp",       "condition",  TRUE,    "Phenotype", NA,
   "Condition",  "HPO_conditions_1.0", "HPO",      1,     "HPO_hp",       "source",     TRUE,    "HP",        NA,
   "Condition",  "HPO_conditions_1.0", "HPO",      1,     "HPO_hp",       "identifier", FALSE,   "id",        NA,
   "Condition",  "HPO_conditions_1.0", "HPO",      2,     "HPO_diseases", "condition",  TRUE,    "Disease",   NA,
   "Condition",  "HPO_conditions_1.0", "HPO",      2,     "HPO_diseases", "source",     FALSE,   "db",        NA,
   "Condition",  "HPO_conditions_1.0", "HPO",      2,     "HPO_diseases", "identifier", FALSE,   "id",        NA
   ),
   ncol=9, byrow=TRUE
) %>%
   set_colnames(cn) %>% 
   as_tibble() %>% 
   mutate(mid=as.integer(mid), static=as.logical(static))
collection_members(file_hpo) <- cm
file_hpo
```

### ClinVar

A subset of the [ClinVar][clinvar] database is provided within this package.
ClinVar is a freely accessible, public archive of reports of the relationships
among human variations and phenotypes, with supporting evidence [!REF!].
This resource can be read as a `fileMDB` as shown above, excepted that all
the documenting information is included in the resource directory in this
case and it is organized as following:

- **DESCRIPTION.json** contains db_information
- **data** is a directory with all the data tables
- **model** is a directory with model information:
   - A **json** file with the ClinVar data model created with
   the [ReDaMoR][redamor] package
   - A **Collections** subfolder with one json file per collection with
   members in the ClinVar resource


```{r}
file_clinvar <- read_fileMDB(
   path=system.file("examples/ClinVar", package="TKCat")
)
```

### CHEMBL

A self-documented subset of the [CHEMBL][chembl] database is also provided
in this package.
It can be read the same way as the ClinVar resource.

```{r}
file_chembl <- read_fileMDB(
   path=system.file("examples/CHEMBL", package="TKCat")
)
```

CHEMBL is a manually curated chemical database of bioactive molecules with
drug-like properties [!REF!].

<!------------->
## MDB implementations

There are 3 main implementations of MDBs:

- **fileMDB** objects keep the data in files and load them only when requested
by the user. These implementation is the first one which is used when reading
MDB as demonstrated in the examples above.

- **memoMDB** objects have all the data loaded in memory. These objects are
very easy to use but can take time to load and can use a lot of memory.

- **chMDB** objects get the data from a ClickHouse database providing a
catalog of MDBs as described in the [chTKCat](#chTKCat) section below.
More information about chTKCat and chMDB objects can also be found in
the [chTKCat user guide][chuguide] and the [chTKCat operational manual][opman].

The different implementations can be converted to each others using
`as_fileMDB()`, `as_memoMDB()` and `as_chMDB()` functions.

```{r}
memo_clinvar <- as_memoMDB(file_clinvar)
object.size(file_clinvar) %>% print(units="Kb")
object.size(memo_clinvar) %>% print(units="Kb")
```


A fourth implementation is **metaMDB** which combines several MDBs glued
together with relational tables
(see the [Merging with collections](#Merging-with-collections) section).

Most of the functions described below work with any MDB implementation.
A few functions are specific of each implementations

<!------------->
## Getting information

### General information

```{r}
db_info(file_clinvar)
```

The function `db_info()<-` can be used to update this information.

### Data model

As shown above the data model of an MDB can be retrieved and plot the following
way.

```{r}
plot(data_model(file_clinvar))
```

Tables names can be listed with the `names()` function and changed
with `names()<-` or `rename()`.

```{r}
names(file_clinvar)
```

The different collection members of an MDBs are listed with
the `collection_members()` function and updated with `collection_members()<-`.

```{r}
collection_members(file_clinvar)
```

### Size

The following functions are use to get the number of tables, the number of
fields per table and the number of records.

```{r}
length(file_clinvar)        # Number of tables
lengths(file_clinvar)       # Number of fields per table
count_records(file_clinvar) # Number of records per table
```

The `count_records()` function can take a lot of time when dealing
with *fileMDB* objects if the data files are very large.
In such case it could be more clever to list data file size.

```{r}
data_file_size(file_clinvar, hr=TRUE)
```

<!------------->
## Pulling, subsetting and combining

There are several possible ways to pull data tables from MDBs.
The following lines return the same results.

```{r, eval=FALSE}
data_tables(file_clinvar, "ClinVar_traitNames")[[1]]
file_clinvar[["ClinVar_traitNames"]]
file_clinvar$"ClinVar_traitNames"
```

```{r}
file_clinvar %>% pull(ClinVar_traitNames)
```

MDBs can also be subset and combined.
The corresponding functions ensure that the data model is fulfilled by the
data tables.

```{r}
file_clinvar[1:3]
c(file_clinvar[1:3], file_hpo[c(1,5,7)]) %>% 
   data_model() %>% auto_layout(force=TRUE) %>% plot()
```

The function `c()` concatenates the provided MDB after checking that tables
names are not duplicated.
It does not integrate the data with any relational table.
This can achieved by merging the MDBs as described in
the [Merging with collections](#Merging-with-collections) section.

<!------------->
## Filtering and joining

An MDB can be filtered by filtering one or several tables based on
field values. The filtering is propagated to other tables using the
embeded data model.

In the example below, the `file_clinvar` object is filtered in order
to focus on a few genes with pathogenic variants
(the tables have been renamed using the `set_names()` function
to improve the readability of the example).
The object returned by `filter()` or `slice` is a *memoMDB*: all the data
are in memory.

```{r, eval=complete}
filtered_clinvar <- file_clinvar %>% 
   set_names(sub("ClinVar_", "", names(.))) %>%
   filter(
      entrezNames = symbol %in% c("PIK3R2", "UGT1A8")
   ) %>% 
   slice(ReferenceClinVarAssertion=grep(
      "pathogen",
      .$ReferenceClinVarAssertion$clinicalSignificance,
      ignore.case=TRUE
   ))
```

Tables can be easily joined to get diseases associated to the genes of interest.

```{r, eval=complete}
gene_traits <- filtered_clinvar %>% 
   join_mdb_tables(
      "entrezNames", "varEntrez", "variants", "rcvaVariant",
      "ReferenceClinVarAssertion", "rcvaTraits", "traits"
   )
gene_traits$entrezNames %>%
   select(symbol, name, variants.type, variants.name, traitType, traits.name)
```

<!------------->
## Merging with collections

```{r, eval=complete}
get_shared_collections(filtered_clinvar, file_chembl)
sel_coll <- get_shared_collections(file_clinvar, file_chembl) %>% 
   filter(collection=="BE")
filtered_cv_chembl <- merge(
   file_clinvar,
   file_chembl,
   by=sel_coll
)
# %>% filter_with_tables(
#    list("ClinVar_entrezNames"=.$ClinVar_entrezNames)
# )
# filtered_cv_chembl %>% 
#    data_model() %>%  plot()
# 
# indications_traits <- filtered_cv_chembl %>%
#    join_mdb_tables(
#       "CHEMBL_drug_indication", "CHEMBL_molecule_dictionary",
#       "CHEMBL_drug_mechanism", "CHEMBL_target_dictionary",
#       "CHEMBL_target_component", "CHEMBL_component_sequence",
#       "BE_1_ClinVar_entrezNames_1_CHEMBL_component_sequence",
#       "ClinVar_entrezNames", "ClinVar_varEntrez", "ClinVar_variants",
#       "ClinVar_rcvaVariant", "ClinVar_ReferenceClinVarAssertion",
#       "ClinVar_rcvaTraits", "ClinVar_traits"
#    )
# indications_traits$CHEMBL_drug_indication %>%
#    select(
#       "indication"="name",
#       "target_name"="CHEMBL_target_dictionary.pref_name",
#       "entrez_gene"="entrez_ClinVar_entrezNames",
#       "gene_name"="ClinVar_entrezNames.name",
#       "gene_symbol"="ClinVar_entrezNames.symbol",
#       "clinical_signif"="ClinVar_ReferenceClinVarAssertion.clinicalSignificance",
#       "trait"="ClinVar_traits.name"
#    ) %>%
#    distinct()
```


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# MDB catalogs as TKCat objects

<!------------->
## Local TKCat

<!------------->
## chTKCat

<!------------->
## A shiny app for exploring MDBs





# Biblio


tidy tuesday

https://relational.fit.cvut.cz : https://arxiv.org/abs/1511.03086

https://www.re3data.org/

https://app.sqldbm.com (ReDaMoR)
